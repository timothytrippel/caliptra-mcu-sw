// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 9022fc2a57bb9af2f3ebc2376b98a807812e2e0f
//
pub const ETHERNET_ADDR: u32 = 0x1000_3000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub EthCtrl [
                /// Start transmitting the frame in TX buffer
                TxStart OFFSET(0) NUMBITS(1) [],
                /// Pop the current RX frame from the queue
                RxPop OFFSET(1) NUMBITS(1) [],
                /// Acknowledge/clear the RX interrupt
                IrqAck OFFSET(2) NUMBITS(1) [],
            ],
            pub EthMacHigh [
                /// MAC address bytes 4-5 (little-endian)
                Addr OFFSET(0) NUMBITS(16) [],
            ],
            pub EthRxLen [
                /// Length of current RX frame
                Len OFFSET(0) NUMBITS(16) [],
            ],
            pub EthRxPtr [
                /// Current read offset in RX buffer
                Ptr OFFSET(0) NUMBITS(16) [],
            ],
            pub EthStatus [
                /// TX buffer is ready to accept data
                TxReady OFFSET(0) NUMBITS(1) [],
                /// At least one RX frame is available
                RxAvail OFFSET(1) NUMBITS(1) [],
                /// TX is currently in progress
                TxBusy OFFSET(2) NUMBITS(1) [],
                /// Number of frames in RX queue
                RxQueueCount OFFSET(8) NUMBITS(8) [],
            ],
            pub EthTxLen [
                /// Length of frame to transmit (max 1514)
                Len OFFSET(0) NUMBITS(16) [],
            ],
            pub EthTxPtr [
                /// Current write offset in TX buffer
                Ptr OFFSET(0) NUMBITS(16) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub Ethernet {
            (0x0 => pub eth_ctrl: tock_registers::registers::ReadWrite<u32, crate::ethernet::bits::EthCtrl::Register>),
            (0x4 => pub eth_status: tock_registers::registers::ReadOnly<u32, crate::ethernet::bits::EthStatus::Register>),
            (0x8 => pub eth_tx_len: tock_registers::registers::ReadWrite<u32, crate::ethernet::bits::EthTxLen::Register>),
            (0xc => pub eth_rx_len: tock_registers::registers::ReadOnly<u32, crate::ethernet::bits::EthRxLen::Register>),
            (0x10 => pub eth_tx_ptr: tock_registers::registers::ReadWrite<u32, crate::ethernet::bits::EthTxPtr::Register>),
            (0x14 => pub eth_rx_ptr: tock_registers::registers::ReadWrite<u32, crate::ethernet::bits::EthRxPtr::Register>),
            (0x18 => pub eth_mac_low: tock_registers::registers::ReadWrite<u32>),
            (0x1c => pub eth_mac_high: tock_registers::registers::ReadWrite<u32, crate::ethernet::bits::EthMacHigh::Register>),
            (0x20 => _reserved0),
            (0x100 => pub eth_tx_data: [tock_registers::registers::ReadWrite<u32>; 379]),
            (0x6ec => _reserved1),
            (0x800 => pub eth_rx_data: [tock_registers::registers::ReadOnly<u32>; 379]),
            (0xdec => @END),
        }
    }
}
