// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 9022fc2a57bb9af2f3ebc2376b98a807812e2e0f
//
#[allow(unused_imports)]
use tock_registers::interfaces::{Readable, Writeable};
pub trait EthernetPeripheral {
    fn set_dma_ram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<caliptra_emu_bus::Ram>>) {}
    fn set_dma_rom_sram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<caliptra_emu_bus::Ram>>) {}
    fn register_event_channels(
        &mut self,
        _events_to_caliptra: std::sync::mpsc::Sender<caliptra_emu_bus::Event>,
        _events_from_caliptra: std::sync::mpsc::Receiver<caliptra_emu_bus::Event>,
        _events_to_mcu: std::sync::mpsc::Sender<caliptra_emu_bus::Event>,
        _events_from_mcu: std::sync::mpsc::Receiver<caliptra_emu_bus::Event>,
    ) {
    }
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn generated(&mut self) -> Option<&mut EthernetGenerated> {
        None
    }
    fn read_eth_ctrl(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthCtrl::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_ctrl();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_eth_ctrl(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthCtrl::Register,
        >,
    ) {
        if let Some(generated) = self.generated() {
            generated.write_eth_ctrl(val);
        }
    }
    fn read_eth_status(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthStatus::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_status();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn read_eth_tx_len(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthTxLen::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_tx_len();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_eth_tx_len(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthTxLen::Register,
        >,
    ) {
        if let Some(generated) = self.generated() {
            generated.write_eth_tx_len(val);
        }
    }
    fn read_eth_rx_len(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthRxLen::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_rx_len();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn read_eth_tx_ptr(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthTxPtr::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_tx_ptr();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_eth_tx_ptr(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthTxPtr::Register,
        >,
    ) {
        if let Some(generated) = self.generated() {
            generated.write_eth_tx_ptr(val);
        }
    }
    fn read_eth_rx_ptr(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthRxPtr::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_rx_ptr();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_eth_rx_ptr(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthRxPtr::Register,
        >,
    ) {
        if let Some(generated) = self.generated() {
            generated.write_eth_rx_ptr(val);
        }
    }
    fn read_eth_mac_low(&mut self) -> caliptra_emu_types::RvData {
        if let Some(generated) = self.generated() {
            return generated.read_eth_mac_low();
        }
        0
    }
    fn write_eth_mac_low(&mut self, val: caliptra_emu_types::RvData) {
        if let Some(generated) = self.generated() {
            generated.write_eth_mac_low(val);
        }
    }
    fn read_eth_mac_high(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthMacHigh::Register,
    > {
        if let Some(generated) = self.generated() {
            return generated.read_eth_mac_high();
        }
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_eth_mac_high(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthMacHigh::Register,
        >,
    ) {
        if let Some(generated) = self.generated() {
            generated.write_eth_mac_high(val);
        }
    }
    fn read_eth_tx_data(&mut self, index: usize) -> caliptra_emu_types::RvData {
        if let Some(generated) = self.generated() {
            return generated.read_eth_tx_data(index);
        }
        0
    }
    fn write_eth_tx_data(&mut self, val: caliptra_emu_types::RvData, index: usize) {
        if let Some(generated) = self.generated() {
            generated.write_eth_tx_data(val, index);
        }
    }
    fn read_eth_rx_data(&mut self, index: usize) -> caliptra_emu_types::RvData {
        if let Some(generated) = self.generated() {
            return generated.read_eth_rx_data(index);
        }
        0
    }
}
#[derive(Clone, Debug)]
pub struct EthernetGenerated {
    eth_ctrl: caliptra_emu_types::RvData,
    eth_status: caliptra_emu_types::RvData,
    eth_tx_len: caliptra_emu_types::RvData,
    eth_rx_len: caliptra_emu_types::RvData,
    eth_tx_ptr: caliptra_emu_types::RvData,
    eth_rx_ptr: caliptra_emu_types::RvData,
    eth_mac_low: caliptra_emu_types::RvData,
    eth_mac_high: caliptra_emu_types::RvData,
    eth_tx_data: Vec<caliptra_emu_types::RvData>,
    eth_rx_data: Vec<caliptra_emu_types::RvData>,
}
impl Default for EthernetGenerated {
    fn default() -> Self {
        Self {
            eth_ctrl: 0 as caliptra_emu_types::RvData,
            eth_status: 0 as caliptra_emu_types::RvData,
            eth_tx_len: 0 as caliptra_emu_types::RvData,
            eth_rx_len: 0 as caliptra_emu_types::RvData,
            eth_tx_ptr: 0 as caliptra_emu_types::RvData,
            eth_rx_ptr: 0 as caliptra_emu_types::RvData,
            eth_mac_low: 0 as caliptra_emu_types::RvData,
            eth_mac_high: 0 as caliptra_emu_types::RvData,
            eth_tx_data: vec![0 as caliptra_emu_types::RvData; 379],
            eth_rx_data: vec![0 as caliptra_emu_types::RvData; 379],
        }
    }
}
impl EthernetGenerated {
    pub fn new() -> Self {
        Self::default()
    }
    fn reset_state(&mut self) {
        *self = Self::default();
    }
}
impl EthernetPeripheral for EthernetGenerated {
    fn generated(&mut self) -> Option<&mut EthernetGenerated> {
        Some(self)
    }
    fn warm_reset(&mut self) {
        self.reset_state();
    }
    fn update_reset(&mut self) {
        self.reset_state();
    }
    fn read_eth_ctrl(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthCtrl::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_ctrl)
    }
    fn write_eth_ctrl(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthCtrl::Register,
        >,
    ) {
        let write_val = (val.reg.get()) as caliptra_emu_types::RvData;
        let current_val = self.eth_ctrl;
        let mut new_val = current_val;
        new_val = (new_val & !(1 as caliptra_emu_types::RvData))
            | (write_val & (1 as caliptra_emu_types::RvData));
        new_val = (new_val & !(2 as caliptra_emu_types::RvData))
            | (write_val & (2 as caliptra_emu_types::RvData));
        new_val = (new_val & !(4 as caliptra_emu_types::RvData))
            | (write_val & (4 as caliptra_emu_types::RvData));
        self.eth_ctrl = new_val;
    }
    fn read_eth_status(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthStatus::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_status)
    }
    fn read_eth_tx_len(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthTxLen::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_tx_len)
    }
    fn write_eth_tx_len(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthTxLen::Register,
        >,
    ) {
        let write_val = (val.reg.get()) as caliptra_emu_types::RvData;
        let current_val = self.eth_tx_len;
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff as caliptra_emu_types::RvData));
        self.eth_tx_len = new_val;
    }
    fn read_eth_rx_len(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthRxLen::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_rx_len)
    }
    fn read_eth_tx_ptr(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthTxPtr::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_tx_ptr)
    }
    fn write_eth_tx_ptr(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthTxPtr::Register,
        >,
    ) {
        let write_val = (val.reg.get()) as caliptra_emu_types::RvData;
        let current_val = self.eth_tx_ptr;
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff as caliptra_emu_types::RvData));
        self.eth_tx_ptr = new_val;
    }
    fn read_eth_rx_ptr(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthRxPtr::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_rx_ptr)
    }
    fn write_eth_rx_ptr(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthRxPtr::Register,
        >,
    ) {
        let write_val = (val.reg.get()) as caliptra_emu_types::RvData;
        let current_val = self.eth_rx_ptr;
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff as caliptra_emu_types::RvData));
        self.eth_rx_ptr = new_val;
    }
    fn read_eth_mac_low(&mut self) -> caliptra_emu_types::RvData {
        self.eth_mac_low
    }
    fn write_eth_mac_low(&mut self, val: caliptra_emu_types::RvData) {
        let write_val = (val) as caliptra_emu_types::RvData;
        let current_val = self.eth_mac_low;
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff_ffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff_ffff as caliptra_emu_types::RvData));
        self.eth_mac_low = new_val;
    }
    fn read_eth_mac_high(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::ethernet::bits::EthMacHigh::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(self.eth_mac_high)
    }
    fn write_eth_mac_high(
        &mut self,
        val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::ethernet::bits::EthMacHigh::Register,
        >,
    ) {
        let write_val = (val.reg.get()) as caliptra_emu_types::RvData;
        let current_val = self.eth_mac_high;
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff as caliptra_emu_types::RvData));
        self.eth_mac_high = new_val;
    }
    fn read_eth_tx_data(&mut self, index: usize) -> caliptra_emu_types::RvData {
        self.eth_tx_data[index]
    }
    fn write_eth_tx_data(&mut self, val: caliptra_emu_types::RvData, index: usize) {
        let write_val = (val) as caliptra_emu_types::RvData;
        let current_val = self.eth_tx_data[index];
        let mut new_val = current_val;
        new_val = (new_val & !(0xffff_ffff as caliptra_emu_types::RvData))
            | (write_val & (0xffff_ffff as caliptra_emu_types::RvData));
        self.eth_tx_data[index] = new_val;
    }
    fn read_eth_rx_data(&mut self, index: usize) -> caliptra_emu_types::RvData {
        self.eth_rx_data[index]
    }
}
pub struct EthernetBus {
    pub periph: Box<dyn EthernetPeripheral>,
}
impl caliptra_emu_bus::Bus for EthernetBus {
    fn read(
        &mut self,
        size: caliptra_emu_types::RvSize,
        addr: caliptra_emu_types::RvAddr,
    ) -> Result<caliptra_emu_types::RvData, caliptra_emu_bus::BusError> {
        if addr & 0x3 != 0 || size != caliptra_emu_types::RvSize::Word {
            return Err(caliptra_emu_bus::BusError::LoadAddrMisaligned);
        }
        match addr {
            0..4 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_ctrl().reg.get(),
            )),
            4..8 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_status().reg.get(),
            )),
            8..0xc => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_tx_len().reg.get(),
            )),
            0xc..0x10 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_rx_len().reg.get(),
            )),
            0x10..0x14 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_tx_ptr().reg.get(),
            )),
            0x14..0x18 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_rx_ptr().reg.get(),
            )),
            0x18..0x1c => Ok(self.periph.read_eth_mac_low()),
            0x1c..0x20 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_eth_mac_high().reg.get(),
            )),
            0x100..0x6ec => Ok(self.periph.read_eth_tx_data((addr as usize - 0x100) / 4)),
            0x800..0xdec => Ok(self.periph.read_eth_rx_data((addr as usize - 0x800) / 4)),
            _ => Err(caliptra_emu_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: caliptra_emu_types::RvSize,
        addr: caliptra_emu_types::RvAddr,
        val: caliptra_emu_types::RvData,
    ) -> Result<(), caliptra_emu_bus::BusError> {
        if addr & 0x3 != 0 || size != caliptra_emu_types::RvSize::Word {
            return Err(caliptra_emu_bus::BusError::StoreAddrMisaligned);
        }
        match addr {
            0..4 => {
                self.periph
                    .write_eth_ctrl(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            4..8 => Ok(()),
            8..0xc => {
                self.periph
                    .write_eth_tx_len(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0xc..0x10 => Ok(()),
            0x10..0x14 => {
                self.periph
                    .write_eth_tx_ptr(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x14..0x18 => {
                self.periph
                    .write_eth_rx_ptr(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x18..0x1c => {
                self.periph.write_eth_mac_low(val);
                Ok(())
            }
            0x1c..0x20 => {
                self.periph
                    .write_eth_mac_high(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x100..0x6ec => {
                self.periph
                    .write_eth_tx_data(val, (addr as usize - 0x100) / 4);
                Ok(())
            }
            0x800..0xdec => Ok(()),
            _ => Err(caliptra_emu_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
