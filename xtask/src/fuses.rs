// Licensed under the Apache-2.0 license

use crate::registers::{file_check_contents, rustfmt, write_file, HEADER_PREFIX, HEADER_SUFFIX};
use anyhow::{anyhow, bail, Result};
use mcu_builder::PROJECT_ROOT;
use registers_generator::snake_case;
use serde::Deserialize;
use std::collections::HashMap;
use std::fmt::Write;
use std::path::{Path, PathBuf};

// The default Caliptra Subsystem OTP memory map file.
const OTP_CTRL_MMAP_DEFAULT_PATH: &str = "hw/caliptra-ss/src/fuse_ctrl/data/otp_ctrl_mmap.hjson";

// Default fuse values for testing provisioning flows.
const FUSE_VALUES_DEFAULT_PATH: &str = "provisioning/fuses/test.hjson";

// Default fuse library for testing provisioning flows.
const FUSE_LIB_DEFAULT_PATH: &str = "provisioning/fuses/test.rs";

// Default in-field provisioning fuse configuration.
const IFP_SPECIFIC_FUSES_DEFAULT_PATH: &str = "hw/fuses.hjson";

const SKIP_PARTITIONS: &[&str] = &[
    "SECRET_MANUF_PARTITION",
    "SECRET_PROD_PARTITION_0",
    "SECRET_PROD_PARTITION_1",
    "SECRET_PROD_PARTITION_2",
    "SECRET_PROD_PARTITION_3",
    "LIFE_CYCLE",
];

#[derive(Debug, Deserialize)]
struct OtpMmap {
    partitions: Vec<OtpPartition>,
}

#[derive(Debug, Deserialize)]
struct OtpPartition {
    name: String,
    size: Option<String>, // bytes
    secret: bool,
    items: Vec<OtpPartitionItem>,
    desc: String,
    sw_digest: bool,
    hw_digest: bool,
}

#[derive(Debug, Deserialize)]
struct OtpPartitionItem {
    name: String,
    size: String, // bytes
}

fn get_file_path_or_default(input_path: Option<&Path>, default: &str) -> PathBuf {
    if let Some(path) = input_path {
        path.to_path_buf()
    } else {
        PROJECT_ROOT.join(default)
    }
}

/// Autogenerate fuse code.
pub(crate) fn autogen_fuses(
    check: bool,
    dest_dir: &Path,
    fuses_hjson_path: Option<&Path>,
    otp_mmap_hjson_path: Option<&Path>,
) -> Result<()> {
    let file_action = if check {
        file_check_contents
    } else {
        write_file
    };

    // Generate combined output from both functions
    let mut header = HEADER_PREFIX.to_string();

    // Parse OTP mmap for partition info
    let mmap_hjson = get_file_path_or_default(otp_mmap_hjson_path, OTP_CTRL_MMAP_DEFAULT_PATH);
    let otp: OtpMmap = serde_hjson::from_str(std::fs::read_to_string(&mmap_hjson)?.as_str())?;
    let partition_mmap = build_partition_mmap(&otp);

    // Generate partition fuses output
    let partition_output = generate_fuse_partitions_from_otp(&otp)?;

    // Generate detailed fuses output if the file exists
    let fuses_hjson = get_file_path_or_default(fuses_hjson_path, IFP_SPECIFIC_FUSES_DEFAULT_PATH);
    let detailed_output = if fuses_hjson.exists() {
        Some(generate_detailed_fuses(fuses_hjson_path, &partition_mmap)?)
    } else {
        None
    };

    // Build combined header
    write!(
        &mut header,
        "\n generated by registers_generator with {}",
        mmap_hjson.file_name().unwrap().to_string_lossy(),
    )?;

    if detailed_output.is_some() {
        write!(
            &mut header,
            " and {}",
            fuses_hjson.file_name().unwrap().to_string_lossy()
        )?;
    }

    header.push_str(HEADER_SUFFIX);

    // Combine outputs
    let mut combined_output = partition_output;
    if let Some(detailed) = detailed_output {
        combined_output += "\n";
        combined_output += &detailed;
    }

    // Write combined output to fuses.rs
    let fuses_file = dest_dir.join("fuses.rs");
    file_action(&fuses_file, &rustfmt(&(header + &combined_output))?)?;

    Ok(())
}

/// Generate a rust library with static fuse values for use during manufacturing provisioning.
pub(crate) fn autogen_fuse_lib(
    otp_mmap_hjson_path: Option<&Path>,
    otp_values_hjson_path: Option<&Path>,
    lib_path: Option<&Path>,
) -> Result<()> {
    // Get input / output file paths.
    let otp_mmap_path = get_file_path_or_default(otp_mmap_hjson_path, OTP_CTRL_MMAP_DEFAULT_PATH);
    let otp_values_path = get_file_path_or_default(otp_values_hjson_path, FUSE_VALUES_DEFAULT_PATH);
    let out_lib_path = get_file_path_or_default(lib_path, FUSE_LIB_DEFAULT_PATH);

    // Parse OTP memory map and desired fuse values.
    let otp_mmap_content = std::fs::read_to_string(otp_mmap_path)?;
    let otp_mmap: OtpMmap = serde_hjson::from_str(&otp_mmap_content)?;
    let otp_values = parse_fuse_values_hjson(&otp_values_path)?;
    validate_fuse_values(&otp_mmap, &otp_values)?;
    println!("Parsed fuse config from: {:?}", otp_values_path);

    // Generate the rust library.
    let lib_content = generate_phf_fuse_value_lib(&otp_mmap, &otp_values)?;
    write_file(&out_lib_path, &rustfmt(&lib_content)?)?;
    println!("Generated fuse config library: {:?}", out_lib_path);

    Ok(())
}

#[derive(Debug, PartialEq)]
enum FuseValue {
    ByteVec(Vec<u8>),
}

impl FuseValue {
    fn from_hjson_value(val: &serde_hjson::Value) -> Result<Self> {
        match val {
            serde_hjson::Value::I64(n) => {
                let n = *n as u64;
                Ok(FuseValue::ByteVec(n.to_le_bytes().to_vec()))
            }
            serde_hjson::Value::U64(n) => Ok(FuseValue::ByteVec(n.to_le_bytes().to_vec())),
            serde_hjson::Value::String(s) => {
                let s = s.trim();
                let s = s.strip_prefix("0x").unwrap_or(s);
                let s = s.trim_end_matches(',');
                let s = s.replace(['_', ' '], "");
                // hex::decode requires an even number of digits.
                let s = if s.len() % 2 != 0 {
                    format!("0{}", s)
                } else {
                    s.to_string()
                };
                let bytes = hex::decode(s)?;
                Ok(FuseValue::ByteVec(bytes))
            }
            serde_hjson::Value::Array(arr) => {
                let bytes: Result<Vec<u8>> = arr
                    .iter()
                    .map(|v| {
                        v.as_u64()
                            .and_then(|n| if n <= 255 { Some(n as u8) } else { None })
                            .ok_or_else(|| anyhow!("Array elements must be bytes (0-255)"))
                    })
                    .collect();
                Ok(FuseValue::ByteVec(bytes?))
            }
            _ => bail!("Unsupported HJSON value type for fuse"),
        }
    }
}

fn parse_fuse_values_hjson(path: &Path) -> Result<HashMap<String, FuseValue>> {
    let content = std::fs::read_to_string(path)?;
    let raw_map: HashMap<String, serde_hjson::Value> = serde_hjson::from_str(&content)?;
    let mut result = HashMap::new();
    for (name, val) in raw_map {
        result.insert(name, FuseValue::from_hjson_value(&val)?);
    }
    Ok(result)
}

fn validate_fuse_values(otp: &OtpMmap, values: &HashMap<String, FuseValue>) -> Result<()> {
    // Collect all valid fuse item names and their sizes.
    let mut item_map = HashMap::new();
    for partition in &otp.partitions {
        if !SKIP_PARTITIONS.contains(&partition.name.as_str()) {
            for item in &partition.items {
                item_map.insert(item.name.clone(), item.size.parse::<usize>()?);
            }
        }
    }
    // Check if field and value size are valid.
    for (name, val) in values {
        let expected_size = item_map
            .get(name)
            .ok_or_else(|| anyhow!("Fuse field '{}' not found in OTP map", name))?;
        let FuseValue::ByteVec(bytes) = val;
        // Check if the value fits in the fuse field. We allow the value to be
        // larger than the field size if the extra bytes are all zeros. This
        // is necessary because HJSON integers are parsed as 8-byte values
        // (i64/u64). See: https://docs.rs/serde-hjson/latest/serde_hjson/enum.Value.html
        if bytes.len() > *expected_size && bytes[*expected_size..].iter().any(|&b| b != 0) {
            bail!(
                "Value for fuse field '{}' is too large ({} bytes, max {} bytes)",
                name,
                bytes.len(),
                expected_size
            );
        }
    }
    Ok(())
}

fn generate_phf_fuse_value_lib(
    otp: &OtpMmap,
    values: &HashMap<String, FuseValue>,
) -> Result<String> {
    let mut output = HEADER_PREFIX.to_string();
    output.push_str(HEADER_SUFFIX);
    output.push_str(
        "\npub static FUSE_VALUES: phf::Map<&'static str, &'static [u8]> = phf::phf_map! {\n",
    );

    // Sort keys for deterministic output
    let mut keys: Vec<&String> = values.keys().collect();
    keys.sort();

    for name in keys {
        let val = values.get(name).unwrap();
        let FuseValue::ByteVec(bytes) = val;

        // Find expected size to pad with zeros if needed
        let mut expected_size = 0;
        'outer: for p in &otp.partitions {
            for item in &p.items {
                if item.name == *name {
                    expected_size = item.size.parse::<usize>()?;
                    break 'outer;
                }
            }
        }

        write!(&mut output, "    \"{}\" => &[", name)?;
        for i in 0..expected_size {
            let byte = bytes.get(i).cloned().unwrap_or(0);
            write!(&mut output, "0x{:02x}, ", byte)?;
        }
        output.push_str("],\n");
    }

    output.push_str("};\n");

    Ok(output)
}

/// Build a map of partition name â†’ PartitionMmapInfo from the parsed OTP mmap.
fn build_partition_mmap(
    otp: &OtpMmap,
) -> std::collections::HashMap<String, mcu_fuses_generator::codegen::PartitionMmapInfo> {
    use mcu_fuses_generator::codegen::{PartitionItemInfo, PartitionMmapInfo};

    let mut map = std::collections::HashMap::new();
    let mut offset: usize = 0;

    for (partition_index, partition) in otp.partitions.iter().enumerate() {
        let digest_size: usize = if partition.hw_digest || partition.sw_digest {
            8
        } else {
            0
        };
        let calculated_size: usize = partition
            .items
            .iter()
            .map(|i| i.size.parse::<usize>().unwrap())
            .sum();

        let calculated_size = if digest_size == 8 {
            calculated_size.next_multiple_of(8) + digest_size
        } else {
            calculated_size.next_multiple_of(4)
        };

        let size = partition
            .size
            .as_ref()
            .map(|s| s.parse::<usize>().unwrap())
            .unwrap_or(calculated_size);

        let mut items = Vec::new();
        let mut item_offset = offset;
        for (entry_num, item) in partition.items.iter().enumerate() {
            let item_size = item.size.parse::<usize>().unwrap();
            let item_name_lower = snake_case(&item.name);
            if item_name_lower.to_ascii_lowercase().ends_with("digest") {
                item_offset = item_offset.next_multiple_of(8);
            }
            items.push(PartitionItemInfo {
                name: item.name.clone(),
                byte_offset: item_offset,
                byte_size: item_size,
                entry_num,
            });
            item_offset += item_size;
        }

        map.insert(
            partition.name.clone(),
            PartitionMmapInfo {
                partition_index,
                byte_offset: offset,
                byte_size: size,
                items,
            },
        );

        offset += size;
    }

    map
}

/// Autogenerate fuse map code from pre-parsed OTP mmap.
fn generate_fuse_partitions_from_otp(otp: &OtpMmap) -> Result<String> {
    let mut output = "".to_string();

    output += "use zeroize::Zeroize;\n";
    output += "/// Fuses contains the data in the OTP controller laid out as described in the controller configuration.\n";
    output += "#[derive(Zeroize)]\n";
    output += "pub struct Fuses {\n";
    let mut impl_output = "impl Fuses {\n".to_string();
    let mut default_impl_output = "impl Default for Fuses {\n".to_string();
    default_impl_output += "fn default() -> Self {\n";
    default_impl_output += "Self {\n";
    let mut const_output = "".to_string();
    let mut offset = 0;
    otp.partitions.iter().for_each(|partition| {
        let name = snake_case(&partition.name);
        let digest_size: usize = if partition.hw_digest || partition.sw_digest {
            8
        } else {
            0
        };
        let calculated_size = partition
            .items
            .iter()
            .map(|i| i.size.parse::<usize>().unwrap())
            .sum::<usize>();

        let calculated_size = if digest_size == 8 {
            // digests need to be aligned to 8-byte boundary
            calculated_size.next_multiple_of(8) + digest_size
        } else {
            // partitions need to be aligned to 4-byte boundary
            calculated_size.next_multiple_of(4)
        };

        let size = partition
            .size
            .as_ref()
            .map(|s| s.parse::<usize>().unwrap())
            .unwrap_or(calculated_size);

        if name != "vendor_test_partition" {
            assert_eq!(calculated_size, size);
        }

        if !SKIP_PARTITIONS.contains(&partition.name.as_str()) {
            output += &format!("/// {}\n", &partition.desc.replace("\n", "\n/// "));
            if !partition.secret {
                output += "#[zeroize(skip)]\n";
            }
            output += &format!("pub {}: [u8; {}],\n", name, size);
            default_impl_output += &format!("{}: [0; {}],\n", name, size);

            let mut item_offset: usize = offset;
            partition.items.iter().for_each(|item| {
                let item_name = snake_case(&item.name);
                let item_size = item.size.parse::<usize>().unwrap();
                // digests need to be 8-byte aligned
                if item_name.to_ascii_lowercase().ends_with("digest") {
                    item_offset = item_offset.next_multiple_of(8);
                }
                if item_size == 1 {
                    impl_output += &format!("pub fn {}(&self) -> u8 {{\n", item_name);
                    impl_output += &format!("    self.{}[{}]\n", name, item_offset - offset);
                    impl_output += "}\n";
                } else {
                    impl_output += &format!("pub fn {}(&self) -> &[u8] {{\n", item_name);
                    impl_output += &format!(
                        "    &self.{}[{}..{}]\n",
                        name,
                        (item_offset - offset),
                        (item_offset + item_size - offset)
                    );
                    impl_output += "}\n";
                }
                item_offset += item_size;
            });
            output += "\n";
        }
        const_output += &format!(
            "pub const {}_BYTE_OFFSET: usize = 0x{:x};\n",
            name.to_uppercase(),
            offset
        );
        const_output += &format!(
            "pub const {}_BYTE_SIZE: usize = 0x{:x};\n",
            name.to_uppercase(),
            size,
        );
        offset += size;
    });
    output += "}\n";
    default_impl_output += "}\n}\n}\n";
    impl_output += "}\n";
    output += &impl_output;
    output += &default_impl_output;
    output += &const_output;

    Ok(output)
}

/// Generate more detailed fuse definitions from the MCU-specific file.
fn generate_detailed_fuses(
    fuses_hjson_path: Option<&Path>,
    partition_mmap: &std::collections::HashMap<
        String,
        mcu_fuses_generator::codegen::PartitionMmapInfo,
    >,
) -> Result<String> {
    let fuses_hjson = get_file_path_or_default(fuses_hjson_path, IFP_SPECIFIC_FUSES_DEFAULT_PATH);
    let hjson_content = std::fs::read_to_string(&fuses_hjson)?;
    let config = mcu_fuses_generator::schema::parse_fuse_hjson_str(&hjson_content)?;
    let generated_code =
        mcu_fuses_generator::codegen::generate_fuses(&config, Some(partition_mmap))?;
    Ok(generated_code)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fuse_value_from_number() {
        let val = serde_hjson::Value::U64(0x1234);
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        let FuseValue::ByteVec(bytes) = fuse_val;
        // 0x1234 in little-endian is [0x34, 0x12, 0, 0, 0, 0, 0, 0]
        assert_eq!(bytes[0], 0x34);
        assert_eq!(bytes[1], 0x12);
        assert_eq!(bytes.len(), 8);
    }

    #[test]
    fn test_fuse_value_from_hex_string() {
        // With 0x
        let val = serde_hjson::Value::String("0xDEADBEEF".to_string());
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![0xDE, 0xAD, 0xBE, 0xEF]));

        // Without 0x
        let val = serde_hjson::Value::String("CAFEBABE".to_string());
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![0xCA, 0xFE, 0xBA, 0xBE]));

        // With underscores and spaces
        let val = serde_hjson::Value::String("0xDE AD_BE EF".to_string());
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![0xDE, 0xAD, 0xBE, 0xEF]));

        // With trailing comma (HJSON artifact)
        let val = serde_hjson::Value::String("0x1234,".to_string());
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![0x12, 0x34]));

        // With odd number of digits
        let val = serde_hjson::Value::String("0x123".to_string());
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![0x01, 0x23]));
    }

    #[test]
    fn test_fuse_value_from_array() {
        let val = serde_hjson::Value::Array(vec![
            serde_hjson::Value::U64(1),
            serde_hjson::Value::U64(2),
            serde_hjson::Value::U64(3),
            serde_hjson::Value::U64(4),
        ]);
        let fuse_val = FuseValue::from_hjson_value(&val).unwrap();
        assert_eq!(fuse_val, FuseValue::ByteVec(vec![1, 2, 3, 4]));
    }

    #[test]
    fn test_fuse_value_invalid_string() {
        let val = serde_hjson::Value::String("not hex".to_string());
        let res = FuseValue::from_hjson_value(&val);
        assert!(res.is_err());
    }

    #[test]
    fn test_validate_fuse_values() {
        let otp = OtpMmap {
            partitions: vec![OtpPartition {
                name: "P1".to_string(),
                size: Some("4".to_string()),
                secret: false,
                items: vec![OtpPartitionItem {
                    name: "F1".to_string(),
                    size: "4".to_string(),
                }],
                desc: "".to_string(),
                sw_digest: false,
                hw_digest: false,
            }],
        };

        let mut values = HashMap::new();
        values.insert("F1".to_string(), FuseValue::ByteVec(vec![1, 2, 3, 4]));

        assert!(validate_fuse_values(&otp, &values).is_ok());

        // Test missing field
        values.insert("F2".to_string(), FuseValue::ByteVec(vec![1]));
        assert!(validate_fuse_values(&otp, &values).is_err());
        values.remove("F2");

        // Test value too large
        values.insert("F1".to_string(), FuseValue::ByteVec(vec![1, 2, 3, 4, 5]));
        assert!(validate_fuse_values(&otp, &values).is_err());

        // Test value from number (will be 8 bytes) for a 4-byte fuse
        let val = serde_hjson::Value::U64(1);
        values.insert("F1".to_string(), FuseValue::from_hjson_value(&val).unwrap());
        // This should now PASS because the extra 4 bytes are zero
        assert!(validate_fuse_values(&otp, &values).is_ok());

        // Test value from number that is actually too large
        let val = serde_hjson::Value::U64(0x1_0000_0000);
        values.insert("F1".to_string(), FuseValue::from_hjson_value(&val).unwrap());
        assert!(validate_fuse_values(&otp, &values).is_err());
    }

    #[test]
    fn test_generate_phf_library() {
        let otp = OtpMmap {
            partitions: vec![OtpPartition {
                name: "P1".to_string(),
                size: Some("4".to_string()),
                secret: false,
                items: vec![OtpPartitionItem {
                    name: "F1".to_string(),
                    size: "4".to_string(),
                }],
                desc: "".to_string(),
                sw_digest: false,
                hw_digest: false,
            }],
        };

        let mut values = HashMap::new();
        values.insert("F1".to_string(), FuseValue::ByteVec(vec![0xAA, 0xBB]));

        let lib = generate_phf_fuse_value_lib(&otp, &values).unwrap();
        assert!(lib.contains("pub static FUSE_VALUES"));
        assert!(lib.contains("phf::phf_map!"));
        assert!(lib.contains("\"F1\" => &[0xaa, 0xbb, 0x00, 0x00, ]"));
    }
}
